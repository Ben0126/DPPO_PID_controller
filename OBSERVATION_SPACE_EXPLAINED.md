# 觀測空間詳細說明：為什麼是 9 維？

## 📊 9 維觀測空間組成

觀測空間定義在 `dppo_pid_env.py` 的 `_get_observation()` 方法中，包含以下 9 個維度：

```python
obs = [
    error / error_scale,           # 維度 0: 追蹤誤差
    error_dot / error_dot_scale,   # 維度 1: 誤差變化率
    integral / integral_scale,     # 維度 2: 積分項
    position / position_scale,     # 維度 3: 當前位置
    velocity / velocity_scale,     # 維度 4: 當前速度
    reference / reference_scale,   # 維度 5: 參考信號
    Kp / gain_scale,              # 維度 6: 當前比例增益
    Ki / gain_scale,              # 維度 7: 當前積分增益
    Kd / gain_scale               # 維度 8: 當前微分增益
]
```

---

## 🔍 各維度詳細說明

### **維度 0: 追蹤誤差 (Error)**
```python
error = reference - position
obs[0] = error / error_scale  # error_scale = 2.0
```

**物理意義**：
- 系統當前位置與目標位置的偏差
- 正值：位置低於目標
- 負值：位置高於目標

**為什麼需要**：
- **直接控制目標**：PID 控制器的核心就是最小化誤差
- **獎勵計算**：誤差平方是獎勵函數的主要組成部分
- **狀態可觀測性**：RL 代理必須知道當前追蹤性能

**正規化範圍**：`error_scale = 2.0` 表示誤差在 ±2.0 範圍內會被正規化到 [-1, 1]

---

### **維度 1: 誤差變化率 (Error Derivative)**
```python
error_dot = -velocity  # 假設參考信號在內層循環中為常數
obs[1] = error_dot / error_dot_scale  # error_dot_scale = 5.0
```

**物理意義**：
- 誤差隨時間的變化速度
- 反映系統的動態響應趨勢
- 正值：誤差在增大（遠離目標）
- 負值：誤差在減小（接近目標）

**為什麼需要**：
- **預測性資訊**：告訴代理系統的運動趨勢
- **PID 微分項**：直接對應 PID 控制器的微分項
- **穩定性判斷**：幫助判斷是否會超調或振盪

**正規化範圍**：`error_dot_scale = 5.0` 表示誤差變化率在 ±5.0 範圍內會被正規化

---

### **維度 2: 積分項 (Integral Term)**
```python
obs[2] = integral / integral_scale  # integral_scale = 10.0
```

**物理意義**：
- PID 控制器中誤差的累積值
- 用於消除穩態誤差
- 反映歷史誤差的總和

**為什麼需要**：
- **穩態精度**：積分項負責消除長期偏差
- **狀態完整性**：代理需要知道積分項的當前值，避免積分飽和
- **反飽和控制**：配合 `integral_max` 限制，防止積分項過大

**正規化範圍**：`integral_scale = 10.0` 表示積分項在 ±10.0 範圍內會被正規化

---

### **維度 3: 當前位置 (Position)**
```python
obs[3] = position / position_scale  # position_scale = 3.0
```

**物理意義**：
- 系統的絕對位置
- 二階系統的狀態變數之一

**為什麼需要**：
- **絕對狀態**：雖然誤差包含相對資訊，但絕對位置也很重要
- **邊界檢查**：幫助判斷是否接近系統邊界（終止條件）
- **上下文資訊**：提供系統的完整狀態描述

**正規化範圍**：`position_scale = 3.0` 表示位置在 ±3.0 範圍內會被正規化

---

### **維度 4: 當前速度 (Velocity)**
```python
obs[4] = velocity / velocity_scale  # velocity_scale = 5.0
```

**物理意義**：
- 系統的運動速度
- 二階系統的另一個狀態變數

**為什麼需要**：
- **動態資訊**：速度是系統動態的關鍵指標
- **振盪檢測**：高速度可能表示系統振盪
- **獎勵計算**：速度平方是獎勵函數的一部分（防止振盪）
- **系統完整性**：二階系統需要位置和速度兩個狀態變數

**正規化範圍**：`velocity_scale = 5.0` 表示速度在 ±5.0 範圍內會被正規化

---

### **維度 5: 參考信號 (Reference)**
```python
obs[5] = reference / reference_scale  # reference_scale = 2.0
```

**物理意義**：
- 目標位置（設定點）
- 系統應該追蹤的目標值

**為什麼需要**：
- **目標資訊**：代理需要知道當前的目標是什麼
- **適應性**：參考信號會定期變化，代理需要適應
- **上下文完整性**：雖然可以從 `error = reference - position` 計算，但直接提供參考信號可以減少計算誤差

**正規化範圍**：`reference_scale = 2.0` 表示參考信號在 ±2.0 範圍內會被正規化（對應 `r_min = -2.0, r_max = 2.0`）

---

### **維度 6-8: PID 增益 (Kp, Ki, Kd)**
```python
obs[6] = Kp / gain_scale   # gain_scale = 10.0
obs[7] = Ki / gain_scale
obs[8] = Kd / gain_scale
```

**物理意義**：
- 當前 PID 控制器的三個增益參數
- 這些是 RL 代理的**動作輸出**，同時也是**狀態的一部分**

**為什麼需要**：
- **狀態完整性**：代理需要知道當前使用的 PID 參數
- **歷史資訊**：幫助代理理解當前的控制策略
- **連續性**：PID 參數的變化是連續的，代理需要知道當前值以做出合理的調整
- **自適應控制**：這是自適應 PID 的核心，代理根據當前增益調整新的增益

**正規化範圍**：`gain_scale = 10.0` 表示增益在 [0, 10.0] 範圍內會被正規化到 [0, 1]

---

## 🎯 為什麼是 9 維？設計理由

### 1. **最小完整狀態表示**

對於一個二階系統 + PID 控制器，理論上需要：

```
系統狀態：
  - 位置 (x)          → 維度 3
  - 速度 (ẋ)          → 維度 4

控制相關：
  - 誤差 (e)          → 維度 0
  - 誤差變化率 (ė)    → 維度 1
  - 積分項 (∫e)       → 維度 2

目標資訊：
  - 參考信號 (r)      → 維度 5

控制參數（當前動作）：
  - Kp                → 維度 6
  - Ki                → 維度 7
  - Kd                → 維度 8
```

**總計：9 維**

### 2. **可觀測性 (Observability)**

所有維度都是**可觀測的**，即：
- 可以直接測量或計算得到
- 不依賴於隱藏狀態
- 提供足夠資訊讓代理做出決策

### 3. **資訊冗餘 vs 計算效率**

**為什麼同時包含誤差和位置/參考？**
- 雖然 `error = reference - position`，但直接提供誤差可以：
  - 減少計算誤差
  - 提供標準化的控制變數
  - 符合 PID 控制的傳統表示

**為什麼包含當前 PID 增益？**
- 雖然增益是代理的動作輸出，但：
  - 代理需要知道當前狀態以做出連續調整
  - 增益的歷史資訊有助於學習
  - 符合部分可觀測馬可夫決策過程 (POMDP) 的設計

### 4. **與動作空間的關係**

```
動作空間 (3 維)：
  action = [Kp, Ki, Kd]

觀測空間 (9 維)：
  obs = [error, error_dot, integral, position, velocity, 
         reference, Kp, Ki, Kd]
         ↑                                    ↑
      系統狀態                              當前動作（歷史）
```

**關鍵洞察**：觀測空間包含**當前的動作值**，這使得：
- 代理可以學習動作的連續性
- 代理可以根據當前增益調整新增益
- 符合自適應控制的設計理念

---

## 📐 正規化策略

所有觀測值都被正規化到 **[-1, 1]** 範圍：

```python
obs = np.clip(obs, -1.0, 1.0)
```

### 正規化參數（來自 `config.yaml`）

| 維度 | 變數 | 縮放因子 | 物理範圍 | 正規化範圍 |
|------|------|---------|---------|-----------|
| 0 | error | 2.0 | ±2.0 | [-1, 1] |
| 1 | error_dot | 5.0 | ±5.0 | [-1, 1] |
| 2 | integral | 10.0 | ±10.0 | [-1, 1] |
| 3 | position | 3.0 | ±3.0 | [-1, 1] |
| 4 | velocity | 5.0 | ±5.0 | [-1, 1] |
| 5 | reference | 2.0 | ±2.0 | [-1, 1] |
| 6 | Kp | 10.0 | [0, 10.0] | [0, 1] |
| 7 | Ki | 10.0 | [0, 5.0] | [0, 0.5] |
| 8 | Kd | 10.0 | [0, 5.0] | [0, 0.5] |

**注意**：Ki 和 Kd 的最大值為 5.0，所以它們的正規化範圍是 [0, 0.5]，而不是 [0, 1]。

### 為什麼需要正規化？

1. **訓練穩定性**：不同尺度的特徵會導致梯度不平衡
2. **神經網路效率**：正規化輸入有助於網路收斂
3. **數值穩定性**：避免極大或極小的值導致數值問題

---

## 🔄 觀測空間的動態更新

觀測空間在每個**外層步驟**（20 Hz）更新：

```python
def step(self, action):
    # 1. 更新 PID 增益（外層）
    self.Kp, self.Ki, self.Kd = action
    
    # 2. 執行內層循環（200 Hz，10 步）
    for inner_step in range(n_inner_steps):
        # ... PID 控制和系統動態 ...
        # 誤差、積分項、位置、速度都會更新
    
    # 3. 返回新的觀測（基於更新後的狀態）
    observation = self._get_observation()
    return observation, reward, terminated, truncated, info
```

**關鍵點**：
- 觀測在**外層頻率**（20 Hz）更新
- 但反映了**內層循環**（200 Hz）的累積效果
- 所有 9 個維度都會根據最新狀態重新計算

---

## 💡 設計優勢

### 1. **資訊完整性**
- 包含系統的所有關鍵狀態
- 提供足夠資訊讓代理做出明智決策

### 2. **標準化表示**
- 所有值正規化到相同範圍
- 有利於神經網路學習

### 3. **可解釋性**
- 每個維度都有明確的物理意義
- 易於理解和調試

### 4. **擴展性**
- 如果需要，可以輕鬆添加新維度（如加速度、干擾估計等）

---

## 🆚 可能的替代設計

### 設計 A：僅包含誤差相關（5 維）
```python
obs = [error, error_dot, integral, reference, velocity]
```
**缺點**：缺少位置和當前增益資訊，可能影響性能

### 設計 B：包含加速度（10 維）
```python
obs = [error, error_dot, integral, position, velocity, 
       acceleration, reference, Kp, Ki, Kd]
```
**優點**：更完整的系統狀態
**缺點**：增加維度可能增加訓練難度

### 設計 C：不包含當前增益（6 維）
```python
obs = [error, error_dot, integral, position, velocity, reference]
```
**缺點**：代理不知道當前使用的增益，可能導致不連續的動作

---

## 📊 總結

**9 維觀測空間的組成**：

1. **控制變數**（3 維）：error, error_dot, integral
2. **系統狀態**（2 維）：position, velocity
3. **目標資訊**（1 維）：reference
4. **控制參數**（3 維）：Kp, Ki, Kd

**設計原則**：
- ✅ 最小完整狀態表示
- ✅ 所有值可觀測
- ✅ 標準化到 [-1, 1]
- ✅ 包含當前動作（增益）以支持連續調整

這個設計平衡了**資訊完整性**和**訓練效率**，是自適應 PID 控制的理想觀測空間表示。

